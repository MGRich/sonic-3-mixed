object 0x38;

event Create() {
    Active = true;
    Priority = true;

    W = 32;
    H = 32;

    Y += 32;

    CurrentAnimation = 2;

    var BlowHeight:int = ((SubType & 0xF) + 8) << 4;
    var HaveBlock:bool = false;
    Solid = false;
    var OutX:int = 0;
    var Underwater:int = 0;
    var AlwaysOn:bool = false;
    var OnOff:bool = false;
    var NeedsActivation:bool = false;
    var On:bool = false;
    var PlayingSound:bool = false;

    if (SubType & 0x80) { // is negative
        HaveBlock = true;
        Solid = true;
        Scene.AddSelfToRegistry(this, "Solid");

        OutX = ((SubType >> 4) & 0x3) << 5;
        if (FlipX) {
            OutX *= -1;
        }

        Priority = true;
    }
    else {
        Underwater = ((SubType >> 6) & 0x1);
        if (((SubType >> 4) & 0x1) == 1) {
            AlwaysOn = true;
        }
        else {
            OnOff = true;
        }

        if (((SubType >> 5) & 0x1) == 1) {
            NeedsActivation = true;
        }

        HaveBlock = false;
        if (FlipX)
            OutX *= -1;
    }
}
event Update() {
    local Out:bool = true;
    local Neck:int = 0;
    for (local i:int =0; i < Scene.PlayerCount; i++) {
        if (Scene.Players[i].EZY >= Y - 24 && Scene.Players[i].OnScreen) {
            Out = false;
        }

        if (Scene.Players[i].Action == ActionType::Hurt || Scene.Players[i].Action == ActionType::Conveyor || Scene.Players[i].Action == ActionType::Dead)
            continue;

        if (On) {
            Neck = IMath::sinHex(Scene.Frame << 2) >> 13;
            if ((Scene.Players[i].X >> 16) + 10 >= X - 16 &&
                (Scene.Players[i].X >> 16) - 10 < X + 16 &&
                (Scene.Players[i].Y >> 16) < Y + 12 &&
                (Scene.Players[i].Y >> 16) >= Y - BlowHeight - 0x30 + Neck) {
                Scene.Players[i].Y += (Y - BlowHeight - 0x30 + Neck - (Scene.Players[i].Y >> 16)) << 10;
                Scene.Players[i].Ground = false;
                Scene.Players[i].YSpeed = -1;
                Scene.Players[i].Action = ActionType::Fan;
            }
        }
    }

    if (OnScreen && !PlayingSound) {
        Sound::Loop(Sound::SFX_FAN_SMALL, 35280);
        PlayingSound = true;
    }
    else if (!OnScreen && PlayingSound) {
        Sound::Stop(Sound::SFX_FAN_SMALL);
        PlayingSound = false;
    }

    if (On) {
        if (Sprite.Animations[CurrentAnimation].AnimationSpeed > 2)
            Frame += Sprite.Animations[CurrentAnimation].AnimationSpeed;
        else if (Sprite.Animations[CurrentAnimation].Frames[Frame / 0x100].Duration != 0)
            Frame += 0x100 / Sprite.Animations[CurrentAnimation].Frames[Frame / 0x100].Duration;

        if (Frame / 0x100 >= Sprite.Animations[CurrentAnimation].FrameCount - 1) {
            Frame = Sprite.Animations[CurrentAnimation].FrameToLoop * 0x100;
        }
    }


    if (!Underwater) {
        if (Out) {
            if (OutX >= 0)
                X = Math.max(InitialX, X - 8);
            else
                X = Math.min(InitialX, X + 8);
            On = true;
        }
        else {
            if (OutX >= 0)
                X = Math.min(InitialX + OutX, X + 8);
            else
                X = Math.max(InitialX + OutX, X - 8);
            On = false;
        }
    }

    if (AlwaysOn)
        On = true;

    if (NeedsActivation) {
        On = false;
        if (Scene.LevelTriggerFlag >= 0x20)
            On = true;
    }

    Out = false;
}
event Render(CamX:int, CamY:int) {
    G.DrawSprite(Sprite, CurrentAnimation, Frame >> 8, (X) - CamX, (Y) - CamY - 28, 0, IE_NOFLIP);

    if (HaveBlock) {
        G.DrawSprite(Scene.TileSprite, 0, 0x8B, 8 + X - CamX + (-16), 8 + Y - CamY + (-16), 0, IE_NOFLIP);
        G.DrawSprite(Scene.TileSprite, 0, 0x8C, 8 + X - CamX + (0), 8 + Y - CamY + (-16), 0, IE_NOFLIP);
        G.DrawSprite(Scene.TileSprite, 0, 0x8D, 8 + X - CamX + (-16), 8 + Y - CamY + (0), 0, IE_NOFLIP);
        G.DrawSprite(Scene.TileSprite, 0, 0x8E, 8 + X - CamX + (0), 8 + Y - CamY + (0), 0, IE_NOFLIP);
    }
}
